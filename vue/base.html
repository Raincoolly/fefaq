<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | 前端面试题</title>
    <meta name="description" content="前端面试题整理">
    
    
    <link rel="preload" href="/assets/css/0.styles.cf70ed5d.css" as="style"><link rel="preload" href="/assets/js/app.74915420.js" as="script"><link rel="preload" href="/assets/js/47.d74a0492.js" as="script"><link rel="prefetch" href="/assets/js/10.bd34cbf4.js"><link rel="prefetch" href="/assets/js/11.a8add717.js"><link rel="prefetch" href="/assets/js/12.dcb5e2cc.js"><link rel="prefetch" href="/assets/js/13.bb04abb1.js"><link rel="prefetch" href="/assets/js/14.999a750d.js"><link rel="prefetch" href="/assets/js/15.ad569e8f.js"><link rel="prefetch" href="/assets/js/16.9f14f8ef.js"><link rel="prefetch" href="/assets/js/17.cc18f972.js"><link rel="prefetch" href="/assets/js/18.e0453436.js"><link rel="prefetch" href="/assets/js/19.ac6a465d.js"><link rel="prefetch" href="/assets/js/2.337978da.js"><link rel="prefetch" href="/assets/js/20.47e552fd.js"><link rel="prefetch" href="/assets/js/21.15aa9870.js"><link rel="prefetch" href="/assets/js/22.12d28b1e.js"><link rel="prefetch" href="/assets/js/23.764a7735.js"><link rel="prefetch" href="/assets/js/24.61d75d1e.js"><link rel="prefetch" href="/assets/js/25.fcf9e416.js"><link rel="prefetch" href="/assets/js/26.057a2669.js"><link rel="prefetch" href="/assets/js/27.5abe5d51.js"><link rel="prefetch" href="/assets/js/28.d4d2b6db.js"><link rel="prefetch" href="/assets/js/29.26b09816.js"><link rel="prefetch" href="/assets/js/3.49b8308b.js"><link rel="prefetch" href="/assets/js/30.5eaa96de.js"><link rel="prefetch" href="/assets/js/31.8eea43f5.js"><link rel="prefetch" href="/assets/js/32.937cb930.js"><link rel="prefetch" href="/assets/js/33.2a201b73.js"><link rel="prefetch" href="/assets/js/34.d182f7e1.js"><link rel="prefetch" href="/assets/js/35.a877cfe2.js"><link rel="prefetch" href="/assets/js/36.0545ea15.js"><link rel="prefetch" href="/assets/js/37.d181e290.js"><link rel="prefetch" href="/assets/js/38.9f053e65.js"><link rel="prefetch" href="/assets/js/39.d80e1b49.js"><link rel="prefetch" href="/assets/js/4.2a599544.js"><link rel="prefetch" href="/assets/js/40.7ffa14c5.js"><link rel="prefetch" href="/assets/js/41.01c34876.js"><link rel="prefetch" href="/assets/js/42.a4418982.js"><link rel="prefetch" href="/assets/js/43.6ac8a75c.js"><link rel="prefetch" href="/assets/js/44.b17e54ba.js"><link rel="prefetch" href="/assets/js/45.eefa8e85.js"><link rel="prefetch" href="/assets/js/46.fad0d18f.js"><link rel="prefetch" href="/assets/js/48.a984657f.js"><link rel="prefetch" href="/assets/js/49.c7725cd9.js"><link rel="prefetch" href="/assets/js/5.c811a82f.js"><link rel="prefetch" href="/assets/js/6.99710472.js"><link rel="prefetch" href="/assets/js/7.30f7f679.js"><link rel="prefetch" href="/assets/js/8.84b5e6e1.js"><link rel="prefetch" href="/assets/js/9.25a55017.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cf70ed5d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">前端面试题</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/base/" class="nav-link">基础</a></div><div class="nav-item"><a href="/advance/" class="nav-link">进阶</a></div><div class="nav-item"><a href="/arithmetic/" class="nav-link">前端算法</a></div><div class="nav-item"><a href="/react/" class="nav-link">react</a></div><div class="nav-item"><a href="/vue/" class="nav-link router-link-active">vue</a></div><div class="nav-item"><a href="/node/" class="nav-link">node</a></div><div class="nav-item"><a href="/computed-base/" class="nav-link">常识</a></div><div class="nav-item"><a href="/simply/" class="nav-link">简版</a></div><div class="nav-item"><a href="/excellent/" class="nav-link">精华</a></div><div class="nav-item"><a href="/print/" class="nav-link">打印</a></div><div class="nav-item"><a href="https://shudong.wang/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/wsdo/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/wsdo/fefaq" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/base/" class="nav-link">基础</a></div><div class="nav-item"><a href="/advance/" class="nav-link">进阶</a></div><div class="nav-item"><a href="/arithmetic/" class="nav-link">前端算法</a></div><div class="nav-item"><a href="/react/" class="nav-link">react</a></div><div class="nav-item"><a href="/vue/" class="nav-link router-link-active">vue</a></div><div class="nav-item"><a href="/node/" class="nav-link">node</a></div><div class="nav-item"><a href="/computed-base/" class="nav-link">常识</a></div><div class="nav-item"><a href="/simply/" class="nav-link">简版</a></div><div class="nav-item"><a href="/excellent/" class="nav-link">精华</a></div><div class="nav-item"><a href="/print/" class="nav-link">打印</a></div><div class="nav-item"><a href="https://shudong.wang/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Blog
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/wsdo/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <a href="https://github.com/wsdo/fefaq" target="_blank" rel="noopener noreferrer" class="repo-link">
    查看源码
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/vue/" class="sidebar-link">vue 面试题</a></li><li><a href="/vue/base.html" class="active sidebar-link">Vue</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/vue/base.html#vue" class="sidebar-link">Vue</a></li></ul></li></ul> </div> <div class="page"> <div class="content"><h2 id="vue"><a href="#vue" aria-hidden="true" class="header-anchor">#</a> Vue</h2> <h3 id="_1-对于mvvm的理解"><a href="#_1-对于mvvm的理解" aria-hidden="true" class="header-anchor">#</a> 1 对于MVVM的理解</h3> <blockquote><p><code>MVVM</code> 是 <code>Model-View-ViewModel</code> 的缩写</p></blockquote> <ul><li><code>Model</code> 代表数据模型，也可以在<code>Model</code>中定义数据修改和操作的业务逻辑。</li> <li><code>View</code> 代表<code>UI</code> 组件，它负责将数据模型转化成<code>UI</code> 展现出来。</li> <li><code>ViewModel</code> 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 <code>Model</code>的对象，连接<code>Model</code>和<code>View</code></li></ul> <blockquote><ul><li>在<code>MVVM</code>架构下，<code>View</code>和 <code>Model</code> 之间并没有直接的联系，而是通过<code>ViewModel</code>进行交互，<code>Model</code>和 <code>ViewModel</code> 之间的交互是双向的， 因此<code>View</code> 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到<code>View</code> 上。</li> <li><code>ViewModel</code> 通过双向数据绑定把 <code>View</code> 层和 <code>Model</code>层连接了起来，而<code>View</code>和 <code>Model</code> 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 <code>MVVM</code> 来统一管理</li></ul></blockquote> <h3 id="_2-请详细说下你对vue生命周期的理解"><a href="#_2-请详细说下你对vue生命周期的理解" aria-hidden="true" class="header-anchor">#</a> 2 请详细说下你对vue生命周期的理解</h3> <blockquote><p>答：总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后</p></blockquote> <ul><li>创建前/后： 在<code>beforeCreate</code>阶段，<code>vue</code>实例的挂载元素<code>el</code>和数据对象<code>data</code>都为<code>undefined</code>，还未初始化。在<code>created</code>阶段，<code>vue</code>实例的数据对象<code>data</code>有了，el还没有</li> <li>载入前/后：在<code>beforeMount</code>阶段，<code>vue</code>实例的<code>$el</code>和<code>data</code>都初始化了，但还是挂载之前为虚拟的<code>dom</code>节点，<code>data.message</code>还未替换。在<code>mounted</code>阶段，<code>vue</code>实例挂载完成，<code>data.message</code>成功渲染。</li> <li>更新前/后：当<code>data</code>变化时，会触发<code>beforeUpdate</code>和<code>updated</code>方法</li> <li>销毁前/后：在执行<code>destroy</code>方法后，对<code>data</code>的改变不会再触发周期函数，说明此时<code>vue</code>实例已经解除了事件监听以及和<code>dom</code>的绑定，但是<code>dom</code>结构依然存在</li></ul> <p><strong>什么是vue生命周期？</strong></p> <ul><li>答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</li></ul> <p><strong>vue生命周期的作用是什么？</strong></p> <ul><li>答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</li></ul> <p><strong>vue生命周期总共有几个阶段？</strong></p> <ul><li>答：它可以总共分为<code>8</code>个阶段：创建前/后、载入前/后、更新前/后、销毁前/销毁后。</li></ul> <p><strong>第一次页面加载会触发哪几个钩子？</strong></p> <ul><li>答：会触发下面这几个<code>beforeCreate</code>、<code>created</code>、<code>beforeMount</code>、<code>mounted</code> 。</li></ul> <p><strong>DOM 渲染在哪个周期中就已经完成？</strong></p> <ul><li>答：<code>DOM</code> 渲染在 <code>mounted</code> 中就已经完成了</li></ul> <h3 id="_3-vue实现数据双向绑定的原理：object-defineproperty"><a href="#_3-vue实现数据双向绑定的原理：object-defineproperty" aria-hidden="true" class="header-anchor">#</a> 3 Vue实现数据双向绑定的原理：Object.defineProperty()</h3> <ul><li><code>vue</code>实现数据双向绑定主要是：采用数据劫持结合发布者-订阅者模式的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的<code>setter</code>，<code>getter</code>，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 <code>Javascript</code> 对象传给 Vue 实例来作为它的 <code>data</code> 选项时，Vue 将遍历它的属性，用 <code>Object.defineProperty()</code> 将它们转为 <code>getter/setter</code>。用户看不到 <code>getter/setter</code>，但是在内部它们让 <code>Vue</code>追踪依赖，在属性被访问和修改时通知变化。</li> <li>vue的数据双向绑定 将<code>MVVM</code>作为数据绑定的入口，整合<code>Observer</code>，<code>Compile</code>和<code>Watcher</code>三者，通过<code>Observer</code>来监听自己的<code>model</code>的数据变化，通过<code>Compile</code>来解析编译模板指令（<code>vue</code>中是用来解析 <code>{{}}</code>），最终利用<code>watcher</code>搭起<code>observer</code>和<code>Compile</code>之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（<code>input</code>）—&gt;数据<code>model</code>变更双向绑定效果。</li></ul> <h3 id="_4-vue组件间的参数传递"><a href="#_4-vue组件间的参数传递" aria-hidden="true" class="header-anchor">#</a> 4 Vue组件间的参数传递</h3> <p><strong>父组件与子组件传值</strong></p> <blockquote><p>父组件传给子组件：子组件通过<code>props</code>方法接受数据；</p></blockquote> <ul><li>子组件传给父组件： <code>$emit</code> 方法传递参数</li></ul> <p><strong>非父子组件间的数据传递，兄弟组件传值</strong></p> <blockquote><p><code>eventBus</code>，就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。项目比较小时，用这个比较合适（虽然也有不少人推荐直接用<code>VUEX</code>，具体来说看需求）</p></blockquote> <h3 id="_5-vue的路由实现：hash模式-和-history模式"><a href="#_5-vue的路由实现：hash模式-和-history模式" aria-hidden="true" class="header-anchor">#</a> 5 Vue的路由实现：hash模式 和 history模式</h3> <ul><li><code>hash</code>模式：在浏览器中符号<code>“#”</code>，#以及#后面的字符称之为<code>hash</code>，用 <code>window.location.hash</code> 读取。特点：<code>hash</code>虽然在<code>URL</code>中，但不被包括在<code>HTTP</code>请求中；用来指导浏览器动作，对服务端安全无用，<code>hash</code>不会重加载页面。</li> <li><code>history</code>模式：h<code>istory</code>采用<code>HTML5</code>的新特性；且提供了两个新方法： <code>pushState()</code>， <code>replaceState()</code>可以对浏览器历史记录栈进行修改，以及<code>popState</code>事件的监听到状态变更</li></ul> <h3 id="_5-vue路由的钩子函数"><a href="#_5-vue路由的钩子函数" aria-hidden="true" class="header-anchor">#</a> 5 vue路由的钩子函数</h3> <blockquote><p>首页可以控制导航跳转，<code>beforeEach</code>，<code>afterEach</code>等，一般用于页面<code>title</code>的修改。一些需要登录才能调整页面的重定向功能。</p></blockquote> <ul><li><code>beforeEach</code>主要有3个参数<code>to</code>，<code>from</code>，<code>next</code>。</li> <li><code>to</code>：<code>route</code>即将进入的目标路由对象。</li> <li><code>from</code>：<code>route</code>当前导航正要离开的路由。</li> <li><code>next</code>：<code>function</code>一定要调用该方法<code>resolve</code>这个钩子。执行效果依赖n<code>ext</code>方法的调用参数。可以控制网页的跳转</li></ul> <h3 id="_6-vuex是什么？怎么使用？哪种功能场景使用它？"><a href="#_6-vuex是什么？怎么使用？哪种功能场景使用它？" aria-hidden="true" class="header-anchor">#</a> 6 vuex是什么？怎么使用？哪种功能场景使用它？</h3> <ul><li>只用来读取的状态集中放在<code>store</code>中； 改变状态的方式是提交<code>mutations</code>，这是个同步的事物； 异步逻辑应该封装在<code>action</code>中。</li> <li>在<code>main.js</code>引入<code>store</code>，注入。新建了一个目录<code>store</code>，<code>… export</code></li> <li><strong>场景有</strong>：单页应用中，组件之间的状态、音乐播放、登录状态、加入购物车</li></ul> <p><img src="https://upload-images.jianshu.io/upload_images/1480597-ad276e57b4a6e555.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vuex"></p> <ul><li><code>state</code>：<code>Vuex</code> 使用单一状态树,即每个应用将仅仅包含一个<code>store</code> 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。</li> <li><code>mutations</code>：<code>mutations</code>定义的方法动态修改<code>Vuex</code> 的 <code>store</code> 中的状态或数据</li> <li><code>getters</code>：类似<code>vue</code>的计算属性，主要用来过滤一些数据。</li> <li><code>action</code>：<code>actions</code>可以理解为通过将<code>mutations</code>里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。<code>view</code> 层通过 <code>store.dispath</code> 来分发 <code>action</code></li></ul> <p><img src="https://upload-images.jianshu.io/upload_images/1480597-0db932c9f1a54213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <blockquote><p><code>modules</code>：项目特别复杂的时候，可以让每一个模块拥有自己的<code>state</code>、<code>mutation</code>、<code>action</code>、<code>getters</code>，使得结构非常清晰，方便管理</p></blockquote> <p><img src="https://upload-images.jianshu.io/upload_images/1480597-d8897c808f913010.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p> <h3 id="_7-v-if-和-v-show-区别"><a href="#_7-v-if-和-v-show-区别" aria-hidden="true" class="header-anchor">#</a> 7 v-if 和 v-show 区别</h3> <ul><li>答：<code>v-if</code>按照条件是否渲染，<code>v-show</code>是<code>display</code>的<code>block</code>或<code>none</code>；</li></ul> <h3 id="_8-route和-router的区别"><a href="#_8-route和-router的区别" aria-hidden="true" class="header-anchor">#</a> 8 <code>$route</code>和<code>$router</code>的区别</h3> <ul><li><code>$route</code>是“路由信息对象”，包括<code>path</code>，<code>params</code>，<code>hash</code>，<code>query</code>，<code>fullPath</code>，<code>matched</code>，<code>name</code>等路由信息参数。</li> <li>而<code>$router</code>是“路由实例”对象包括了路由的跳转方法，钩子函数等</li></ul> <h3 id="_9-如何让css只在当前组件中起作用"><a href="#_9-如何让css只在当前组件中起作用" aria-hidden="true" class="header-anchor">#</a> 9 如何让CSS只在当前组件中起作用?</h3> <blockquote><p>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></p></blockquote> <h3 id="_10-keep-alive-keep-alive-的作用是什么"><a href="#_10-keep-alive-keep-alive-的作用是什么" aria-hidden="true" class="header-anchor">#</a> 10 <code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>的作用是什么?</h3> <ul><li><code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例,主要用于保留组件状态或避免重新渲染</li></ul> <blockquote><p>比如有一个列表和一个详情，那么用户就会经常执行打开详情=&gt;返回列表=&gt;打开详情…这样的话列表和详情都是一个频率很高的页面，那么就可以对列表组件使用<code>&lt;keep-alive&gt;&lt;/keep-alive&gt;</code>进行缓存，这样用户每次返回列表的时候，都能从缓存中快速渲染，而不是重新渲染</p></blockquote> <h3 id="_11-指令v-el的作用是什么"><a href="#_11-指令v-el的作用是什么" aria-hidden="true" class="header-anchor">#</a> 11 指令v-el的作用是什么?</h3> <blockquote><p>提供一个在页面上已存在的 <code>DOM</code>元素作为 <code>Vue</code>实例的挂载目标.可以是 CSS 选择器，也可以是一个 <code>HTMLElement</code> 实例,</p></blockquote> <h3 id="_12-在vue中使用插件的步骤"><a href="#_12-在vue中使用插件的步骤" aria-hidden="true" class="header-anchor">#</a> 12 在Vue中使用插件的步骤</h3> <ul><li>采用<code>ES6</code>的<code>import ... from ...</code>语法或<code>CommonJS</code>的<code>require()</code>方法引入插件</li> <li>使用全局方法<code>Vue.use( plugin )</code>使用插件,可以传入一个选项对象<code>Vue.use(MyPlugin, { someOption: true })</code></li></ul> <h3 id="_13-请列举出3个vue中常用的生命周期钩子函数"><a href="#_13-请列举出3个vue中常用的生命周期钩子函数" aria-hidden="true" class="header-anchor">#</a> 13 请列举出3个Vue中常用的生命周期钩子函数?</h3> <ul><li><code>created</code>: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, <code>watch/event</code>事件回调. 然而, 挂载阶段还没有开始, <code>$el</code>属性目前还不可见</li> <li><code>mounted</code>: <code>el</code>被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 <code>root</code> 实例挂载了一个文档内元素，当 <code>mounted</code>被调用时 <code>vm.$el</code> 也在文档内。</li> <li><code>activated</code>: <code>keep-alive</code>组件激活时调用</li></ul> <h3 id="_14-vue-cli-工程技术集合介绍"><a href="#_14-vue-cli-工程技术集合介绍" aria-hidden="true" class="header-anchor">#</a> 14 vue-cli 工程技术集合介绍</h3> <p><strong>问题一：构建的 vue-cli 工程都到了哪些技术，它们的作用分别是什么？</strong></p> <ul><li><code>vue.js</code>：<code>vue-cli</code>工程的核心，主要特点是 双向数据绑定 和 组件系统。</li> <li><code>vue-router</code>：<code>vue</code>官方推荐使用的路由框架。</li> <li><code>vuex</code>：专为 <code>Vue.js</code> 应用项目开发的状态管理器，主要用于维护<code>vue</code>组件间共用的一些 变量 和 方法。</li> <li><code>axios</code>（ 或者 <code>fetch</code> 、<code>ajax</code> ）：用于发起 <code>GET</code> 、或 <code>POST</code> 等 <code>http</code>请求，基于 <code>Promise</code> 设计。</li> <li><code>vuex</code>等：一个专为<code>vue</code>设计的移动端<code>UI</code>组件库。</li> <li>创建一个<code>emit.js</code>文件，用于<code>vue</code>事件机制的管理。</li> <li><code>webpack</code>：模块加载和<code>vue-cli</code>工程打包器。</li></ul> <p><strong>问题二：vue-cli 工程常用的 npm 命令有哪些？</strong></p> <ul><li>下载 <code>node_modules</code> 资源包的命令：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm install
</code></pre></div><ul><li>启动 <code>vue-cli</code> 开发环境的 npm命令：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm run dev
</code></pre></div><ul><li><code>vue-cli</code> 生成 生产环境部署资源 的 <code>npm</code>命令：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm run build
</code></pre></div><ul><li>用于查看 <code>vue-cli</code> 生产环境部署资源文件大小的 <code>npm</code>命令：</li></ul> <div class="language- extra-class"><pre class="language-text"><code>npm run build --report
</code></pre></div><blockquote><p>在浏览器上自动弹出一个 展示 <code>vue-cli</code> 工程打包后 <code>app.js</code>、<code>manifest.js</code>、<code>vendor.js</code> 文件里面所包含代码的页面。可以具此优化 <code>vue-cli</code> 生产环境部署的静态资源，提升 页面 的加载速度</p></blockquote> <h3 id="_15-nexttick"><a href="#_15-nexttick" aria-hidden="true" class="header-anchor">#</a> 15 NextTick</h3> <blockquote><p><code>nextTick</code>可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 <code>DOM</code></p></blockquote> <h3 id="_16-vue的优点是什么？"><a href="#_16-vue的优点是什么？" aria-hidden="true" class="header-anchor">#</a> 16 vue的优点是什么？</h3> <ul><li>低耦合。视图（<code>View</code>）可以独立于<code>Model</code>变化和修改，一个<code>ViewModel</code>可以绑定到不同的<code>&quot;View&quot;</code>上，当View变化的时候Model可以不变，当<code>Model</code>变化的时候<code>View</code>也可以不变</li> <li>可重用性。你可以把一些视图逻辑放在一个<code>ViewModel</code>里面，让很多<code>view</code>重用这段视图逻辑</li> <li>可测试。界面素来是比较难于测试的，而现在测试可以针对<code>ViewModel</code>来写</li></ul> <h3 id="_17-路由之间跳转？"><a href="#_17-路由之间跳转？" aria-hidden="true" class="header-anchor">#</a> 17 路由之间跳转？</h3> <p><strong>声明式（标签跳转）</strong></p> <div class="language- extra-class"><pre class="language-text"><code>&lt;router-link :to=&quot;index&quot;&gt;
</code></pre></div><p><strong>编程式（ js跳转）</strong></p> <div class="language- extra-class"><pre class="language-text"><code>router.push('index')
</code></pre></div><h3 id="_18-实现-vue-ssr"><a href="#_18-实现-vue-ssr" aria-hidden="true" class="header-anchor">#</a> 18 实现 Vue SSR</h3> <p><img src="http://7xq6al.com1.z0.glb.clouddn.com/vue-ssr.jpg" alt></p> <p><strong>其基本实现原理</strong></p> <ul><li><code>app.js</code> 作为客户端与服务端的公用入口，导出 <code>Vue</code> 根实例，供客户端 <code>entry</code> 与服务端 <code>entry</code> 使用。客户端 <code>entry</code> 主要作用挂载到 <code>DOM</code> 上，服务端 <code>entry</code> 除了创建和返回实例，还进行路由匹配与数据预获取。</li> <li><code>webpack</code> 为客服端打包一个 <code>Client Bundle</code> ，为服务端打包一个 <code>Server Bundle</code> 。</li> <li>服务器接收请求时，会根据 <code>url</code>，加载相应组件，获取和解析异步数据，创建一个读取 <code>Server Bundle</code> 的 <code>BundleRenderer</code>，然后生成 <code>html</code> 发送给客户端。</li> <li>客户端混合，客户端收到从服务端传来的 <code>DOM</code> 与自己的生成的 DOM 进行对比，把不相同的 <code>DOM</code> 激活，使其可以能够响应后续变化，这个过程称为客户端激活 。为确保混合成功，客户端与服务器端需要共享同一套数据。在服务端，可以在渲染之前获取数据，填充到 <code>stroe</code> 里，这样，在客户端挂载到 <code>DOM</code> 之前，可以直接从 <code>store</code>里取数据。首屏的动态数据通过 <code>window.__INITIAL_STATE__</code>发送到客户端</li></ul> <blockquote><p><code>Vue SSR</code> 的实现，主要就是把 <code>Vue</code> 的组件输出成一个完整 <code>HTML</code>, <code>vue-server-renderer</code> 就是干这事的</p></blockquote> <ul><li><code>Vue SSR</code>需要做的事多点（输出完整 HTML），除了<code>complier -&gt; vnode</code>，还需如数据获取填充至 <code>HTML</code>、客户端混合（<code>hydration</code>）、缓存等等。
相比于其他模板引擎（<code>ejs</code>, <code>jade</code> 等），最终要实现的目的是一样的，性能上可能要差点</li></ul> <h3 id="_19-vue-组件-data-为什么必须是函数"><a href="#_19-vue-组件-data-为什么必须是函数" aria-hidden="true" class="header-anchor">#</a> 19 Vue 组件 data 为什么必须是函数</h3> <ul><li>每个组件都是 <code>Vue</code> 的实例。</li> <li>组件共享 <code>data</code> 属性，当 <code>data</code> 的值是同一个引用类型的值时，改变其中一个会影响其他</li></ul> <h3 id="_20-vue-computed-实现"><a href="#_20-vue-computed-实现" aria-hidden="true" class="header-anchor">#</a> 20 Vue computed 实现</h3> <ul><li>建立与其他属性（如：<code>data</code>、 <code>Store</code>）的联系；</li> <li>属性改变后，通知计算属性重新计算</li></ul> <blockquote><p>实现时，主要如下</p></blockquote> <ul><li>初始化 <code>data</code>， 使用 <code>Object.defineProperty</code> 把这些属性全部转为 <code>getter/setter</code>。</li> <li>初始化 <code>computed</code>, 遍历 <code>computed</code> 里的每个属性，每个 <code>computed</code> 属性都是一个 <code>watch</code> 实例。每个属性提供的函数作为属性的 <code>getter</code>，使用 <code>Object.defineProperty</code> 转化。</li> <li><code>Object.defineProperty getter</code> 依赖收集。用于依赖发生变化时，触发属性重新计算。</li> <li>若出现当前 <code>computed</code> 计算属性嵌套其他 <code>computed</code> 计算属性时，先进行其他的依赖收集</li></ul> <h3 id="_21-vue-complier-实现"><a href="#_21-vue-complier-实现" aria-hidden="true" class="header-anchor">#</a> 21 Vue complier 实现</h3> <ul><li>模板解析这种事，本质是将数据转化为一段 <code>html</code> ，最开始出现在后端，经过各种处理吐给前端。随着各种 <code>mv*</code> 的兴起，模板解析交由前端处理。</li> <li>总的来说，<code>Vue complier</code> 是将 <code>template</code> 转化成一个 <code>render</code> 字符串。</li></ul> <blockquote><p>可以简单理解成以下步骤：</p></blockquote> <ul><li><code>parse</code> 过程，将 <code>template</code> 利用正则转化成<code>AST</code> 抽象语法树。</li> <li><code>optimize</code> 过程，标记静态节点，后 <code>diff</code> 过程跳过静态节点，提升性能。</li> <li><code>generate</code> 过程，生成 <code>render</code> 字符串</li></ul> <h3 id="_22-怎么快速定位哪个组件出现性能问题"><a href="#_22-怎么快速定位哪个组件出现性能问题" aria-hidden="true" class="header-anchor">#</a> 22 怎么快速定位哪个组件出现性能问题</h3> <blockquote><p>用 <code>timeline</code> 工具。 大意是通过 <code>timeline</code> 来查看每个函数的调用时常，定位出哪个函数的问题，从而能判断哪个组件出了问题</p></blockquote></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com//wsdo/fefaq/edit/master/vue/base.md" target="_blank" rel="noopener noreferrer">帮助我们改善此页面！</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">3/11/2019, 4:31:25 PM</span></div></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/vue/" class="prev router-link-active">
          vue 面试题
        </a></span> <!----></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.74915420.js" defer></script><script src="/assets/js/47.d74a0492.js" defer></script>
  </body>
</html>
